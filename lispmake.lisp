(in-package :lispmake)

;; lispmake, written by Matthew Veety, et al.
;; (c) Matthew Veety 2012,2013,2014. Under BSD License.
;; 
;; This is a hacked together program designed to generate the build
;; files that are required for a client's lisp set up. If you find
;; bugs or better ways to do things then send in patches.
;; 
;; Things that need doing:
;;     * Support for clisp, cmucl, ccl, and I guess others
;;     * build targets (ala make) (could be a plugin)
;;     * testing. It works for me, it might not for you

(defun generate ()
  (with-open-file (mkfile (output-fname) :direction :output :if-exists :supersede)
    (format 
     mkfile 
     ";; autogenerated by lispmake revision ~A~%;; DO NOT EDIT~%"
     *lispmake-version*)
    (run-plugin-pregen mkfile)
    (dolist (x *quickloads*)
      (lm-debug "generate" "generating quicklisp forms")
      (quickloads mkfile x))
    (dolist (x *sources*)
      (lm-debug "generate" "generating load forms")
      (loadfile mkfile x))
    (lm-debug "generate" "generating save-and-die form")
    (buildexe mkfile *outfile* *lm-package* *toplevel* *lisp-target*)
    (force-output mkfile)
    (run-plugin-postgen mkfile))
  (if *debugging*
      (format t "lispmake: doing build...~%"))
  (if *do-build*
      (run-build-process)))

(defun runner (forms)
  (if (not (listp forms))
      (lm-error "runner" "form not of type cons in LMakefile")
      (progn
	(let* ((cmd (car forms))
	       (args (cdr forms))
	       (pfun (getf *plugins* cmd)))
	  (lm-debug "runner" (format nil "cmd = ~A, args = ~A~%" cmd args))
	  (if (nilp pfun)
	      (lm-error "runner" (format nil "unknown command: ~A" cmd))
	      (funcall pfun args))))))

(defun fix-and-eval (args)
  (eval (append '(progn) args)))

(defun pl-echo (args)
  (if (not (listp args))
      (lm-error "echo" "invalid arguments")
      (progn
	(dolist (x args)
	  (format t "~A" (varhdl x)))
	(terpri))))

(defun pl-include (args)
  (let ((fname (car args)))
    (if (probe-file fname)
	(with-open-file (incfile fname)
	  (loop for form = (read incfile nil nil)
		until (eq form nil) do
		  (lm-debug "include" (format nil "reading form: ~A~%" form))
		  (runner form)))
	(lm-error "include" (format nil "file not found: ~A~%" fname)))))

(defun main ()
  (in-package :lispmake)
  (handle-options)
  (initialize-vars)
  (if *debugging*
      (format t "lispmake r~A~%" *lispmake-version*)
      (disable-debugger))
  (install-plugin :package 'pl-package)
  (install-plugin :toplevel 'pl-toplevel)
  (install-plugin :file 'pl-file)
  (install-plugin :output 'pl-output)
  (install-plugin :quicklisp 'pl-quicklisp)
  (install-plugin :generate
		  (lambda (args)
		    (declare (ignore args))
		    (setf *generate* (not *generate*))))
  (install-plugin :eval
		  (lambda (args)
		    (fix-and-eval args)))
  (install-plugin :echo 'pl-echo)
  (install-plugin :lisp
		  (lambda (args)
		    (setf *lisp-target* (car args))))
  (install-plugin :compile-file 'pl-compile-file)
  (install-plugin :build-with 'pl-lisp-executable)
  (install-plugin :do-build
		  (lambda (args)
		    (declare (ignore args))
		    (if (not *do-build-override*)
			(setf *do-build* (not *do-build*)))))
  (install-plugin :exec 'pl-exec)
  (install-plugin :install 'pl-install)
  (install-plugin :delete 'pl-delete)
  (install-plugin :define 'pl-define)
  (install-plugin :require-file 'pl-require-file)
  (install-plugin :configure 'pl-configure)
  (install-plugin :include 'pl-include)
  (install-plugin :apply-prefix 'pl-apply-prefix)
  (install-pregen-hook 'pl-compile-file-pregen)
  (with-open-file (lmkfile *lmakefile*)
    (loop for form = (read lmkfile nil nil)
	 until (eq form nil)
	 do (progn
	      (lm-debug "main" (format nil "reading form ~A~%" form))
	      (runner form)))
    (if *generate*
	(progn
	  (lm-debug "main" (format nil "generating run-~A.lisp~%" (output-fname)))
	  (generate))))
  (if *debugging* (progn
		    (print *variables*)
		    (terpri))))
